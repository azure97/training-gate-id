\input{../config.tex}

\title{Matematika Diskret Dasar}
\author{Tim Olimpiade Komputer Indonesia}
\date{}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{Pendahuluan}
Melalui dokumen ini, kalian akan:
\begin{itemize}
  \item Mempelajari \newTerm{aritmetika modular}.
  \item Memahami FPB dan KPK.
  \item Mempelajari algoritma \newTerm{Prime Generation}.
  \item Memahami sifat dan penggunaan kombinatorika.
  \item Mempelajari dan memanfaatkan \newTerm{Pigeon Hole Principle}.
\end{itemize}
\end{frame}

\section{Arimetika Modular}
\frame{\sectionpage}

\begin{frame}
\frametitle{Konsep Modulo}
\begin{itemize}
  \item $a \equiv b \;(\bmod\; n)$ dapat dibaca \statement{$a \;kongruen \;b \;modulo \;n$}.
  \item $a \equiv b \;(\bmod\; n)$ hanya jika selisih $a$ dan $b$ merupakan kelipatan dari $n$.
  \item Dengan kata lain, sisa hasil bagi $a$ dan $b$ oleh $n$ bernilai sama.
  \item Contoh: $5 \equiv 1 \;(\bmod\; 4)$ , $-8 \equiv 7 \;(\bmod\; 5)$.
  \item Biasanya, kita menggunakan operasi $\mod$ untuk mencari bilangan non-negatif terkecil $b$, sehingga $a \equiv b \;(\bmod\; n)$.
  \item Operasi modulo \emp{tidak dapat dilakukan} dalam modulo \emp{0!}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Sifat-Sifat Modulo}
Seandainya $a \equiv b \;(\bmod\; n)$ dan $c \equiv d \;(\bmod\; n)$, maka :
\begin{itemize}
  \item $a + c \equiv b + d \;(\bmod\; n)$
  \item $a - c \equiv b - d \;(\bmod\; n)$
  \item $ac \equiv bd \;(\bmod\; n)$
\end{itemize}
\end{frame} 

\begin{frame}[fragile]
\frametitle{Aplikasi Modulo}
\begin{itemize}
  \item Pada \textit{Competitive Programming}, tidak jarang kita harus menghitung $n! \mod k$ (terutama dalam kombinatorika). 
  \item Seandainya kita menghitung $n!$ , kemudian menggunakan operasi $\mod$, kemungkinan besar kita akan mendapatkan \emp{overflow!}
  \item Untungnya, kita bisa menggunakan sifat modulo!
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Aplikasi Modulo (lanj.)}
Solusi: 
\begin{lstlisting}
  function faktorialModular(n, k : longint) : longint;
  var
    i, jawaban : longint;
  begin
    jawaban := 1;
    for i := 1 to n do begin
      jawaban := (jawaban * i) mod k;
    end

    faktorialModular := jawaban;
  end;  
\end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Hati-Hati!}
\begin{itemize}
  \item Aritmetika modular tidak langsung bekerja pada pembagian.
  \item $\frac{a}{b} \; (\bmod\; n) \; \neq \; \frac{a \mod n}{b \mod n} \; (\bmod\; n)$.
  \item Contohnya, $\frac{12}{4} \; (\bmod\; 6) \; \neq \; \frac{12 \mod 6}{4 \mod 6} \; (\bmod\; 6)$.
  \item Pada aritmetika modular, $\frac{a}{b} \; (\bmod\; n)$ biasa kita tulis sebagai $a * b^{-1}\;(\bmod\; n)$, dimana $b^{-1}$ adalah 
      \newTerm{Modular Multiplicative Inverse} dari $b$.
  \item Jika tertarik, anda bisa mempelajari \textit{Modular Multiplicative Inverse} melalui \textcolor{blue}{\href{https://en.wikipedia.org/wiki/  Modular_multiplicative_inverse}{link wikipedia ini}.} 
\end{itemize}
\end{frame}

\section{FPB dan KPK}
\frame{\sectionpage}

\begin{frame}
\frametitle{Faktorisasi Prima}
\begin{itemize}
  \item Ketika masih SD, tentunya kita pernah belajar memfaktorkan bilangan dengan pohon faktor.
  \item Melalui faktorisasi prima, kita dapat menyatakan suatu bilangan sebagai hasil kali perkalian faktor-faktornya.
  \item Contoh: $7875 = 3^{2} * 5^{3} * 7$ .
  \item Faktorisasi prima ini dapat bermanfaat pada soal-soal matematika di \textit{Competitive Programming}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{FPB dan KPK}
\begin{itemize}
  \item Ketika masih SD, kita pernah diajari cara mencari FPB dan KPK melalui faktorisasi prima. Singkatnya, untuk setiap bilangan prima, kita menggunakan pangkat terkecil untuk FPB dan pangkat terbesar untuk KPK.
  \item Contoh : $4725 = 3^{3} * 5^{2} * 7$ dan $7875 = 3^{2} * 5^{3} * 7$.
  \item Maka, $FPB(4725,7875) = 3^{2} * 5^{2} * 7 = 1525$ dan $KPK(4725,7875) = 3^{3} * 5^{3} * 7 = 23625$.
  \item Jika kita observasi, $KPK(a,b) = \frac{a * b}{FPB(a,b)}$. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Algoritma Euclid}
\begin{itemize}
  \item Untuk mencari FPB suatu bilangan, menggunakan pohon faktor \emp{sangat berat!}
  \item Terdapat algoritma yang dapat mencari $FPB(a,b)$ dalam $O(min(a,b))$.
  \item Solusi:
  \begin{lstlisting}
  function euclid(a,b : longint) : longint;
  begin
    if (b = 0) then begin
      euclid := a;
    end
    else begin
      euclid := euclid(b,a mod b);
    end;
  end;
  \end{lstlisting}
  \item Jika anda tertarik, anda dapat membaca lebih lanjut \textcolor{blue}{\href{https://en.wikipedia.org/wiki/Euclidean_algorithm}{di link wikipedia ini}.}   
\end{itemize}
\end{frame}

\section{Generating Prime}
\frame{\sectionpage}

\begin{frame}
\frametitle{Solusi Awal}
\begin{itemize}
  \item Kita tahu bahwa bilangan prima merupakan bilangan yang hanya habis dibagi 1 dan dirinya sendiri.
  \item Oleh karena itu, kita dapat melakukan \textit{looping} untuk mengecek apakah suatu bilangan prima atau tidak.
  \item Maka, untuk tiap bilangan, kita coba-coba keterbagiannya dengan bilangan lain. Karena ada $N$ bilangan dan $N-2$ kemungkinan pembagi, maka kompleksitas solusi ini $O(N^{2})$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Solusi Awal (lanj.)}
Solusi:
  \begin{lstlisting}
  procedure naiveGeneration(n : longint);
  var
    i, j : longint;
    prima : boolean;
  begin
    for i := 1 to n do begin
        prima := true;
        for j := 2 to n - 1 do begin
          if (i mod j == 0) then begin
            prima := false;
          end;  
        end;
        if (prima) then begin
          writeln(i, ' adalah bilangan prima');
        end;
    end;
  end;  
  \end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Solusi $\sqrt{N}$}
\begin{itemize}
  \item Kita dapat mengobservasi bahwa jika $x = a * b$, dan $a \leq b$, maka $a \leq \sqrt{x}$ dan $b \geq \sqrt{x}$.
  \item Oleh karena itu, kita cukup mengecek kemungkinan pembagi hingga $\sqrt{x}$.
  \item Maka, kita dapat mengoptimasi solusi sebelumnya menjadi $O(N\sqrt{N})$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Solusi $\sqrt{N}$ (lanj.)}
Solusi:
  \begin{lstlisting}
  procedure optimizedGeneration(n : longint);
  var
    i, j : longint;
    prima : boolean;
  begin
    for i := 1 to n do begin
        prima := true;
        for j := 2 to trunc(sqrt(i)) do begin
          if (i mod j == 0) then begin
            prima := false;
          end;  
        end;
        if (prima) then begin
          writeln(i, ' adalah bilangan prima');
        end;
    end;
  end;  
  \end{lstlisting}
\end{frame}

\begin{frame}
\frametitle{Sieve of Erathostenes}
\begin{itemize}
  \item Terdapat solusi yang lebih optimal untuk membangkitkan bilangan prima, yaitu \newTerm{Sieve of Erathostenes}.
  \item Ide utama dari algoritma ini adalah menandai tiap bilangan komposit. Hal ini dapat dilakukan dengan \textit{looping} dari tiap bilangan prima dan \textit{array} untuk menandai.
  \item Jika kita melakukan \textit{looping} dari nilai yang kecil, jelas bahwa bilangan prima tidak akan tertandai.
  \item Kompleksitas solusi ini $O(N\;log\;log\;N)$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sieve of Erathostenes (lanj.)}
Solusi:
  \begin{lstlisting}
    procedure sieveOfErathostenes(n : longint);
    var
      i, j : longint;
      flag : array[1..100000] of boolean;
    begin
      for i := 2 to n do 
        if (not flag[i]) then begin
          writeln(i, ' adalah bilangan prima').
          j = i;
          while(i * j <= n) do begin
            flag[i * j] = true;
            inc(j);
          end;
        end;
    end;  
  \end{lstlisting}
\end{frame}

\section{Pigeon Hole Principle}
\frame{\sectionpage}

\begin{frame}
\frametitle{Motivasi}
\begin{itemize}
  \item Mari kita tinjau soal OSP 2015 no. 50.
  \item Inti permasalahan ini adalah mencari apakah pada \textit{array} berukuran $N$, terdapat \textit{subset} tidak kosong yang jumlahan elemennya habis dibagi $N$.
  \item Jika ada, outputkan indeks-indeks dari \textit{subset} yang diambil. Jika tidak, outputkan -1.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi (lanj.)}
\begin{itemize}
  \item Mari kita coba mengerjakan versi lebih mudah dari soal ini. Bagaimana jika yang diminta \textit{subsequence}, bukan \textit{subset}?
  \item Misal kita memiliki fungsi $sum(k) = \sum\limits_{i=1}^k array[i]$.
  \item Bagaimana hubungan \textit{subsequence} yang habis dibagi $N$ seandainya kita kaitkan dengan $sum(k)$ dan sifat modulo?
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi (lanj.)}
\begin{itemize}
  \item Kita dapat menyimpulkan bahwa $\sum\limits_{i=l}^r array[i] = sum(r) - sum(l - 1)$.
  \item Jika habis dibagi $N$, maka $sum(r) - sum(l - 1) \equiv 0 \; (\bmod \; N)$.
  \item Ini dapat kita tuliskan sebagai $sum(r) \equiv sum(l - 1) \;(\bmod\; N)$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi (lanj.)}
\begin{itemize}
  \item Observasi 1 : ada N buah kemungkinan nilai sum(x), yaitu [0...N-1].
  \item Observasi 2 : ada N+1 buah kemungkinan nilai x untuk sum(x), yaitu [0..N]. Nilai 0 harus ada agar \textit{subsequence} dalam bentuk (1,k) untuk tiap k dapat kita nyatakan dalam bentuk dari slide sebelumnya.
  \item Observasi 3 : Karena ada N+1 kemungkinan nilai x, dan ada N buah kemungkinan nilai sum(x), maka \emp{pasti ada 2 buah indeks, a dan b, sehingga $sum(b) \equiv sum(a) \;(\bmod\; N)$.} 
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Motivasi (lanj.)}
\begin{itemize}
  \item Dengan menyelesaikan versi mudah dari soal awal kita, ternyata kita justru dapat menyelesaikan soal tersebut.
  \item Konsep \statement{Jika ada $N$ nilai dan $M$ kotak, dimana $M \ge N$ , maka ada setidaknya 2 kotak yang memiliki nilai sama} biasa disebut sebagai \newTerm{Pigeon Hole Principle}.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Pigeon Hole Principle}
\begin{itemize}
  \item Konsep PHP adalah \statement{Jika ada $N$ nilai dan $M$ kotak, dimana $M > N$ , maka ada setidaknya 2 kotak yang memiliki nilai sama}.
  \item Secara matematis, jika ada $N$ nilai dan $M$ kotak, maka ada setidaknya $\big\lceil \frac{M}{N} \big\rceil$ kotak yang memiliki nilai sama.
\end{itemize}
\end{frame}

\end{document}
